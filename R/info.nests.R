#' Calculate statistics about nests
#' @title Calculte statistics about nests
#' @author Marc Girondot
#' @return Return or the total likelihood or a list with $metric and $summary depending on out parameter
#' @param x A set of parameters to model the embryo growth thermal reaction norm or a NestsResult object.
#' @param parameters A set of parameters to model the embryo growth thermal reaction norm. It will replace the parameters included in NestsResult (same as x).
#' @param NestsResult A NestsResult object generated by searchR to model the embryo growth thermal reaction
#' @param resultmcmc A mcmc result for embryo growth thermal reaction norm
#' @param hessian An hessian matrix for embryo growth thermal reaction norm. It will replace the hessian matrix included in NestResult object.
#' @param CI How to estimate CI for embryo growth thermal reaction norm; can be NULL, "SE", "MCMC", or "Hessian".
#' @param fixed.parameters A set of fixed parameters to model the embryo growth thermal reaction norm. It will replace the fixed parameters included in NestsResult.
#' @param SE Standard error for each parameter. It will replace the SE in NestsResult. Use SE=NA to remove SE from NestResult
#' @param temperatures Timeseries of temperatures formatted using formatNests(). It will replace the one in NestsResult.
#' @param derivate Function used to fit embryo growth: dydt.Gompertz, dydt.exponential or dydt.linear. It will replace the one in NestsResult.
#' @param test Mean and SD of size of hatchlings. It will replace the one in NestsResult.
#' @param weight Weights of the different nests to estimate likelihood. It will replace the one in NestsResult.
#' @param stopattest TRUE or FALSE. If TRUE, the model stops when proxy of size reached the mean test size.
#' @param M0 Measure of hatchling size proxi at laying date. It will replace the one in NestsResult.
#' @param SexualisationTRN A set of parameters used to model sexualisation thermal reaction norm during TSP or a result of STRN()
#' @param SexualisationTRN.mcmc A mcmc object obtained from STRN_MHmcmc() to generate variability for sexualisation thermal reaction norm during TSP
#' @param SexualisationTRN.CI How to estimate CI of sexualisation thermal reaction norm. Can be NULL, "SE", "MCMC", or "Hessian".
#' @param series The name or number of the series to be estimated.
#' @param TSP.borders The limits of TSP in stages. See embryo.stages parameter.
#' @param embryo.stages The embryo stages. At least TSP.borders stages must be provided to estimate TSP borders. See note.
#' @param TSP.begin Where TSP begin during the stage of beginning? In relative proportion of the stage.
#' @param TSP.end Where TSP begin during the stage of ending? In relative proportion of the stage.
#' @param replicate.CI Number of replicates to estimate CI. If <2, no CI is estimated.
#' @param metabolic.heating Degrees Celsius to be added at the end of incubation due to metabolic heating.
#' @param temperature.heterogeneity SD of heterogeneity of temperatures. Can be 2 values, sd_low and sd_high and then HelpersMG::r2norm() is used.
#' @param fill Number of minutes between two records. Create new one if they do not exist. NULL does not change the time of temperature recordings.
#' @param out Can take the values of "likelihood" or "metric" or "summary". "metric" and "summary" can be combined: c("metric", "summary")
#' @param metric.end.incubation The expected metric at the end of incubation. Used to calibrate TSP size. If NULL, take the maximum Mean of the test parameter. If NA, use the actual final size. Can be a vector and is recycled if necessary.
#' @param progress If FALSE, the progress bar is not shown (useful for using with sweave or knitr)
#' @param warnings If FALSE, does not show warnings
#' @param parallel If TRUE use parallel version for nests estimation
#' @description This function calculates many statistics about nests.\cr
#' The embryo.stages is a named vector with relative size as compared to final size at the beginning of the stage. Names are the stages.\cr
#' For example for SCL in Caretta caretta:\cr
#' embryo.stages=structure(c(8.4, 9.4, 13.6, 13.8, 18.9, 23.5, 32.2, 35.2, 35.5, 38.5)/39.33), \cr
#' .Names = c("21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31"))\cr
#'  indicates that the stages 21 begins at the relative size of 8.4/39.33.\cr
#' Series can be indicated as the name of the series, their numbers or series or sucession of TRUE or FALSE. "all" indicates that all series must be analyzed.\cr
#' The likelihood object is just the total likelihood of the data in the model.\cr
#' If one parameter is named "pipping_emergence" it is used as the number of days between pipping and emergence to calculate the 1/3 and 2/3 of incubation.\cr
#' The summary object is a data.frame composed of these elements:
#' \itemize{
#'   \item \code{TimeWeighted.temperature.mean} Average temperature weigthed by the time at each temperature for all incubation
#'   \item \code{TimeWeighted.temperature.se} Standard error for the average temperature weigthed by the time at each temperature for all incubation
#'   \item \code{MassWeighted.temperature.mean} Average temperature weigthed by the growth of embryo for all incubation
#'   \item \code{MassWeighted.temperature.se} Standard error for the average temperature weigthed by the growth of embryo for all incubation
#'   \item \code{TSP.TimeWeighted.temperature.mean} Average temperature during the TSP weigthed by the time at each temperature
#'   \item \code{TSP.TimeWeighted.temperature.se} Standard error for the average temperature during the TSP weigthed by the time at each temperature
#'   \item \code{TSP.MassWeighted.temperature.mean} Average temperature during the TSP weigthed by the mass increase at each temperature
#'   \item \code{TSP.MassWeighted.temperature.se} Standard error for the average temperature during the TSP weigthed by the mass increase at each temperature
#'   \item \code{TSP.STRNWeighted.temperature.mean} Averaged temperature during the TSP weighted by sexualisation thermal reaction norm
#'   \item \code{TSP.STRNWeighted.temperature.se} Standard error for temperature during the TSP weighted by sexualisation thermal reaction norm
#'   \item \code{TSP.MassWeighted.STRNWeighted.temperature.mean} Averaged temperature during the TSP weighted by sexualisation thermal reaction norm and embryo growth
#'   \item \code{TSP.MassWeighted.STRNWeighted.temperature.se} Standard error for temperature during the TSP weighted by sexualisation thermal reaction norm and embryo growth
#'   \item \code{TSP.length.mean} Average length of the TSP
#'   \item \code{TSP.length.se} Standard error for length of the TSP
#'   \item \code{TSP.begin.mean} Average time of the beginning of the TSP
#'   \item \code{TSP.begin.se} Standard error for the beginning of the TSP
#'   \item \code{TSP.end.mean} Average time of the endd of the TSP
#'   \item \code{TSP.end.se} Standard error for the end of the TSP
#'   \item \code{Incubation.length.mean} Average number of days for the incubation length
#'   \item \code{Incubation.length.se} Standard error for number of days for the incubation length
#'   \item \code{Middlethird.begin.mean} Average day at which the middle third incubation begins
#'   \item \code{Middlethird.begin.se} Standard error for day at which the middle third incubation begins
#'   \item \code{Middlethird.end.mean} Average day at which the middle third incubation ends
#'   \item \code{Middlethird.end.se} Standard error at which the middle third incubation ends
#'   \item \code{Middlethird.length.mean} Average days for second third of incubation
#'   \item \code{Middlethird.length.se} Standard error for second third of incubation
#'   \item \code{MiddleThird.TimeWeighted.temperature.mean} Average temperature during the middle third of incubation
#'   \item \code{MiddleThird.TimeWeighted.temperature.se} Standard error for the temperature during the middle third of incubation
#'   \item \code{MiddleThird.MassWeighted.temperature.mean} Average temperature during the middle third of incubation weighted by embryo growth
#'   \item \code{MiddleThird.MassWeighted.temperature.se} Standard error for temperature during the middle third of incubation weighted by embryo growth
#' }
#' The metric object is a list composed of data.frames which have the following attributes for each element of the list:
#' \itemize{
#'   \item \code{time.begin.tsp} Average time at the beginning of TSP
#'   \item \code{time.end.tsp} Average time at the end of TSP
#'   \item \code{time.begin.middlethird} Average time at the beginning of the middle third of incubation
#'   \item \code{time.begin.middlethird} Average time at the end of the middle third of incubation
#'   \item \code{time.begin.tsp.se} Standard error for the time at the beginning of TSP
#'   \item \code{time.end.tsp.se} Standard error for the time at the end of TSP
#'   \item \code{time.begin.middlethird.se} Standard error for the time at the beginning of the middle third of incubation
#'   \item \code{time.end.middlethird.se} Standard error for the time at the end of the middle third of incubation
#'   \item \code{stopattest} NA if stopattest was false, TRUE if at least one incubation series was longer than hatchling size and FALSE at contrary
#' }
#' If you indicate new set of temperatures, you must probably also indicate new test values.\cr
#' Note: four species have predefined embryo stages. embryo.stages parameter can take the values:\cr
#' \itemize{
#'   \item \code{Caretta caretta.SCL}
#'   \item \code{Chelonia mydas.SCL}
#'   \item \code{Emys orbicularis.SCL}
#'   \item \code{Emys orbicularis.mass}
#'   \item \code{Podocnemis expansa.SCL}
#'   }
#' But remember that mass is not the best proxy to describe the growth of an embryo because it can decrease if the subtrate becomes dry.\cr
#' The progress bar is based on both replicates and timeseries.
#' @examples
#' \dontrun{
#' library(embryogrowth)
#' data(resultNest_4p_SSM4p)
#' summary.nests <- info.nests(resultNest_4p_SSM4p, out="summary", replicate.CI=100, 
#'   resultmcmc=resultNest_mcmc_4p_SSM4p, 
#'   CI="MCMC", 
#'   progress=TRUE)
#'   # Result is in summary.nests$summary
#' infoall <- info.nests(resultNest_4p_SSM4p)
#'   # Result is a value
#' infoall.df <- info.nests(resultNest_4p_SSM4p, out="metric", replicate.CI=100, 
#'   resultmcmc=resultNest_mcmc_4p_SSM4p, 
#'   CI="MCMC", 
#'   progress=TRUE)
#' # Result is in summary.nests$metric
#' infoall.both <- info.nests(resultNest_4p_SSM4p, out=c("metric", "summary"), replicate.CI=100, 
#'   resultmcmc=resultNest_mcmc_4p_SSM4p, 
#'   CI="MCMC", 
#'   progress=TRUE)
#' # Results are in summary.nests$summary and in summary.nests$metric
#' infoall.both <- info.nests(resultNest_4p_SSM4p, out=c("metric", "summary"), replicate.CI=100, 
#'   CI="Hessian", 
#'   progress=TRUE)
#' infoall.both <- info.nests(resultNest_4p_SSM4p, out=c("metric", "summary"), replicate.CI=100, 
#'   CI="SE", 
#'   progress=TRUE)
#' }
#' @export


info.nests <- function(x=NULL, parameters=NULL, NestsResult=NULL, 
                       resultmcmc=NULL,
                       hessian=NULL,
                       CI=NULL, 
                       fixed.parameters=NULL, 
                       SE=NULL, temperatures=NULL, derivate=NULL, 
                       test=NULL, stopattest=FALSE, M0=NULL, series="all",
                       TSP.borders=NULL, embryo.stages=NULL,
                       TSP.begin=0, TSP.end=0.5, 
                       replicate.CI=1, weight=NULL, out="likelihood", fill=NULL, 
                       SexualisationTRN=NULL, SexualisationTRN.mcmc=NULL, 
                       SexualisationTRN.CI=NULL, 
                       metric.end.incubation=NA,
                       metabolic.heating=0, 
                       temperature.heterogeneity=0, 
                       progress=FALSE, warnings=TRUE, parallel=TRUE) {
  
  # x=NULL; parameters=NULL; NestsResult=NULL; resultmcmc=NULL; fixed.parameters=NULL; SE=NULL; hessian=NULL; CI=NULL; temperatures=NULL; temperature.heterogeneity=0; metabolic.heating=0; derivate=NULL; test=NULL; stopattest=FALSE; M0=NULL; series="all"; TSP.borders=NULL; embryo.stages=NULL; replicate.CI=1; weight=NULL; out="Likelihood"; fill=NULL; SexualisationTRN.CI=NULL; SexualisationTRN=NULL;SexualisationTRN.mcmc=NULL; metric.end.incubation=NA; progress=TRUE;warnings=TRUE; parallel=TRUE
  #  x=resultNest_4p_SSM4p; resultmcmc = resultNest_mcmc_4p_SSM4p; out <- "summary"
  # temperatures = formated; parameters = structure(c(4.46266058827153e-03, 26.0095385510809, 35.5257746031439),.Names = c("Dallwitz_b1", "Dallwitz_b2", "Dallwitz_b3")); series = 1; out=c("likelihood"); derivate=dydt.linear; M0=1.7; test=c(Mean=1, SD=0.01)
  #    library("deSolve")
  #    parameters <- x
  
  if (!is.null(CI)) CI <- tolower(CI)
  if (!is.null(SexualisationTRN.CI)) SexualisationTRN.CI <- tolower(SexualisationTRN.CI)
 
  windows <- (.Platform$OS.type == "windows")
  
  papply <- ifelse(parallel, detectCores(), 1)
  
  if (windows & parallel) {
    cl <- makeCluster(detectCores())
    s <- clusterEvalQ(cl = cl , library(embryogrowth))
  }
  
  q975 <- qnorm(0.975)
  if (class(x)=="NestsResult") NestsResult <- x
  if (class(x)=="numeric") parameters <- x
  
  out <- tolower(out)
  TSP.list <- embryogrowth::TSP.list
  
  
  if (class(SexualisationTRN)=="STRN") {
    SexualisationTRN.fixed.parameters <- SexualisationTRN$fixed.parameters
    SexualisationTRN.hessian <- SexualisationTRN$hessian
    SexualisationTRN.SE <- SexualisationTRN$SE
    SexualisationTRN <- SexualisationTRN$par
    if (!is.null(SexualisationTRN.SE[1])) {
      if (all(is.infinite(SexualisationTRN.SE[])) | all(is.na(SexualisationTRN.SE[]))) {
        SexualisationTRN.SE <- NULL
      } else {
        SexualisationTRN.SE <- ifelse(is.infinite(SexualisationTRN.SE), 0, SexualisationTRN.SE)
      }
    }
  } else {
    # soit c'est null soit c'est numérique
    SexualisationTRN.fixed.parameters <- NULL
    SexualisationTRN.hessian <- NULL
  }
  
  if (!is.null(SexualisationTRN.mcmc)) {
      nrSTRN <- nrow(SexualisationTRN.mcmc$resultMCMC[[1]])
  }
  
  if (class(NestsResult)=="NestsResult") {
    # temperatures est un objet Nests
    if (is.null(hessian)) hessian <- NestsResult$hessian
    if (is.null(temperatures)) temperatures <- NestsResult$data
    if (is.null(derivate)) derivate <- NestsResult$derivate
    if (is.null(weight)) weight <- NestsResult$weight
    if (is.null(test)) test <- NestsResult$test
    if (is.null(M0)) M0 <- NestsResult$M0
    if (is.null(fixed.parameters)) fixed.parameters <- NestsResult$fixed.parameters
    if (is.null(SE)) SE <- NestsResult$SE
    if (is.null(parameters)) parameters <- NestsResult$par
  }
  
  
  # Si je ne fais que la vraisemblance, je n'ai pas besoin de CI
  if (length(out) == 1) if (out=="likelihood") CI <- NULL
  
  if (!is.null(SE[1])) if (all(is.na(SE[])))  SE <- NULL
  CIr <- CI
  if (!is.null(CI)) {
    if ((CI == "mcmc") & is.null(resultmcmc)) {
      CIr <- NULL
      if (warnings) warning("CI is indicated as MCMC but no resultmcmc is available.")
    }
    if ((CI == "se") & is.null(SE)) {
      CIr <- NULL
      if (warnings) warning("CI is indicated as SE but no SE is available.")
    }
    if (CI == "hessian" & is.null(hessian)) {
      CIr <- NULL
      if (warnings) warning("CI is indicated as Hessian but no Hessian matrix is available.")
    }
    if (replicate.CI <= 1) CIr <- NULL
  }
  CI <- CIr
  if (is.null(CI)) {
    CI <- "null"
    replicate.CI <- 1
  }
  
  SexualisationTRN.CIr <- SexualisationTRN.CI
  
  if (!is.null(SexualisationTRN.CI)) {
  
  if (SexualisationTRN.CI == "mcmc" & is.null(SexualisationTRN.mcmc)) {
    SexualisationTRN.CIr <- NULL
    if (warnings) warning("SexualisationTRN.CI is indicated as MCMC but no SexualisationTRN.mcmc is available.")
  }
  
  
  if (SexualisationTRN.CI == "hessian" & is.null(SexualisationTRN.hessian)) {
    SexualisationTRN.CIr <- NULL
    if (warnings) warning("SexualisationTRN.CI is indicated as Hessian but no Hessian matrix is available.")
  } else {
    sigma.STRN <- solve(SexualisationTRN.hessian)
    s. <- svd(sigma.STRN)
    R.STRN <- t(s.$v %*% (t(s.$u) * sqrt(pmax(s.$d, 0))))
    # pre0.9_9994 = FALSE
  }
  
  if (SexualisationTRN.CI == "se" & is.null(SexualisationTRN.SE)) {
    SexualisationTRN.CIr <- NULL
    if (warnings) warning("SexualisationTRN.CI is indicated as SE but no SE is available.")
  }
  
  }
  
  SexualisationTRN.CI <- SexualisationTRN.CIr
    
  if (is.null(SexualisationTRN.CI)) {
    SexualisationTRN.CI <- "null"
  }  

  if (is.numeric(NestsResult) & is.null(parameters)) parameters <- NestsResult
  
  NBTs <- temperatures[["IndiceT"]][3]
  
  if (is.null(series[1]) | (series[1]=="all")) {
    series <- rep(TRUE, NBTs)
  }
  
  # Je ne garde que les series que je dois travailler
  temperatures_ec <- temperatures[1:NBTs][series]
  
  # Dans NBTs j'ai maintenant le nombre de series a travailler
  NBTs <- length(temperatures_ec)
  
  # dans name j'ai le nom des series que je vais travailler
  name <- names(temperatures_ec)
  names(name) <- name
  
  if (is.null(test)) {
    # si tous sont pareils, je reprends les memes
    # Correction d'un bug, rajout de [[1]] dans result$test["Mean"][[1]][1] 30/7/2012
    if (all(NestsResult$test["Mean"]==NestsResult$test["Mean"][[1]][1]) & all(NestsResult$test["SD"]==NestsResult$test["SD"][[1]][1])) {
      test <- c(Mean=NestsResult$test["Mean"][[1]][1], SD=NestsResult$test["SD"][[1]][1])
    } else {	
      stop("The hatchlings size (test parameter) must be provided.")
    }
  }
  
  
  if (class(test) == "numeric") {
    test <- data.frame(Mean=rep(test["Mean"], NBTs), SD=rep(test["SD"], NBTs), row.names=name)
  }
  
  if (is.null(metric.end.incubation)) {
    metric.end.incubation <- rep(max(test[, "Mean"]), NBTs)
    names(metric.end.incubation) <- name
  }
  # if (is.na(metric.end.incubation)) metric.end.incubation <- 1
  
  if (length(metric.end.incubation) != NBTs | is.null(names(metric.end.incubation))) {
    metric.end.incubation <- rep(metric.end.incubation, NBTs)[1:NBTs]
    names(metric.end.incubation) <- name
  }
  
  if (class(embryo.stages)=="character") {
    estages <- TSP.list[[gsub(" ", "_", embryo.stages)]]
    if (is.null(estages)) {
      stop("The TSP for ", embryo.stages, " does not exist")
    } else {
      embryo.stages <- estages[, "metric"]
      names(embryo.stages) <- estages[, "stages"]
      TSP.borders <- c(attributes(estages)$TSP.begin.stages, attributes(estages)$TSP.end.stages)
    }
  }
  
  # La taille au dbut et fin de TSP devrait dependre de la taille finale
  # A mditer
  # C'est resolu le 16/9/2015
  
  if (!is.null(embryo.stages) & !is.null(TSP.borders)) {
    size.begin.TSP <- embryo.stages[as.character(TSP.borders[1])]
    if (TSP.begin != 0) {
      size.begin.TSP <- size.begin.TSP+(embryo.stages[as.character(TSP.borders[1]+1)]-size.begin.TSP)*TSP.begin
    }
    
    size.end.TSP <- mean(embryo.stages[as.character(TSP.borders[2])])
    if (TSP.end != 0) {
      size.end.TSP <- size.end.TSP+(embryo.stages[as.character(TSP.borders[2]+1)]-size.end.TSP)*TSP.end
    }
  } else {
    size.end.TSP <- NA
    size.begin.TSP <- NA
  }
  
  # dans x j'ai les parametres a ajuster
  # Il faut que je rajoute les fixes - 16/7/2012
  totpar <- c(parameters, fixed.parameters)
  if (is.na(totpar["pipping_emergence"])) totpar <- c(totpar, pipping_emergence=0)
  # logictransition vaut TRUE s'il n'y en a pas !
  logicTransition <- (is.na(totpar["transition_P"]) | is.na(totpar["transition_S"]))
  # je gere les series
  # 23-11_2016: Ca ne sert a rien
  # df_random <- data.frame(fake=rep(NA, replicate.CI))

# les différentes solutions sont: SE, hessian ou mcmc
  # je dois être plus clair sur ce que j'utilise
if (CI == "mcmc") {
  ########### Je donne un MCMC
  ########### Je vais l'utiliser directement
  df_random <- matrix(data = rep(totpar, replicate.CI), byrow = TRUE, 
                      nrow = replicate.CI, dimnames = list(c(NULL), names(totpar)))
  
  samp <- sample(1:nrow(resultmcmc$resultMCMC[[1]]), replicate.CI-1, replace = TRUE)
  df_random[2:replicate.CI, colnames(resultmcmc$resultMCMC[[1]])] <- resultmcmc$resultMCMC[[1]][samp, colnames(resultmcmc$resultMCMC[[1]])]
  
}

  if (CI == "se") {
    SE <- ifelse(is.infinite(SE), 0, SE)
    df_random <- matrix(data = rep(totpar, replicate.CI), byrow = TRUE, 
                        nrow = replicate.CI, dimnames = list(c(NULL), names(totpar)))
    for (ise in names(SE)) df_random[2:replicate.CI, ise] <- rnorm(n = replicate.CI-1, mean=totpar[ise], sd=SE[ise])
}
  
  if (CI == "hessian") {
    # df_random <- rmvnorm(n=replicate.CI, mean=totpar[rownames(hessian)], sigma=solve(hessian), method="svd")
    sigma <- solve(hessian)
    s. <- svd(sigma)
    R <- t(s.$v %*% (t(s.$u) * sqrt(pmax(s.$d, 0))))
    
    # pre0.9_9994 = FALSE
    
    df_random <- matrix(rnorm(replicate.CI * ncol(sigma)), nrow = replicate.CI, byrow = TRUE) %*% R
    df_random <- sweep(df_random, 2, totpar[rownames(hessian)], "+")
    colnames(df_random) <- rownames(hessian)
    
    ajouter <- matrix(rep(totpar[names(totpar)[!(names(totpar) %in% colnames(df_random))]], replicate.CI), 
                      nrow=replicate.CI, byrow=TRUE,
                      dimnames = list(c(NULL), names(totpar)[!(names(totpar) %in% colnames(df_random))]))
    df_random <- cbind(df_random, ajouter)
  }
  
  if (CI == "null") {
    df_random <- t(as.matrix(totpar))
  }
  
  # dans name j'ai les noms des series
  
  if (windows & parallel) {
    # save(list = ls(all.names = TRUE), file = "total.Rdata", envir = environment())
    
    # temperatures_ec <- temperatures_ec
    
    clusterExport(cl = cl, 
                  varlist=c("temperatures_ec", "fill", "M0"), 
                  envir = environment())
    
    temperatures_ec2 <- parLapply(cl=cl, X=name, fun=function (xxx) {
      #      temperatures_ec <- lapply(xx, function (xxx) {
      # xxx <- 1
      df <- as.data.frame(temperatures_ec[[xxx]])
      colnames(df) <- c("Time", "TempC", "TempK", "R", "SCL", "IndiceK")
      
      
      if (!is.null(fill)) {
        newt <- seq(from=fill, to=tail(df$Time, n=1L), by=fill)
        aretirer <- -which(!is.na(match(newt, df$Time)))
        if (!identical(aretirer, integer(0))) newt <- newt[aretirer]
        df <- rbind(df, 
                    data.frame(Time=newt, TempC=NA, 
                               TempK=NA, R=NA, SCL=NA, IndiceK=NA)) 
        df <- df[order(df$Time),]
      }
      
      df <- cbind(df, DeltaT=c(diff(df$Time), 0))
      
      ind <- which(!is.na(df$TempC))      # get positions of nonmissing values
      if(is.na(df$TempC[1]))             # if it begins with a missing, add the 
        ind <- c(1,ind)        # first position to the indices
      df$TempC <- rep(df$TempC[ind], times = diff(   # repeat the values at these indices
        c(ind, length(df$TempC) + 1) ))
      df$TempK <- rep(df$TempK[ind], times = diff(   # repeat the values at these indices
        c(ind, length(df$TempK) + 1) ))
      df$IndiceK <- rep(df$IndiceK[ind], times = diff(   # repeat the values at these indices
        c(ind, length(df$IndiceK) + 1) ))
      
      df[1, "SCL"] <- M0
      return(df)
    })

  } else {
  # prepare le df pour les resultats
  temperatures_ec2 <- mclapply(X=name, mc.cores = papply, FUN=function (xxx) {
    #      temperatures_ec <- lapply(xx, function (xxx) {
    # xxx <- 1
    df <- as.data.frame(temperatures_ec[[xxx]])
    colnames(df) <- c("Time", "TempC", "TempK", "R", "SCL", "IndiceK")
    
    
    if (!is.null(fill)) {
      newt <- seq(from=fill, to=tail(df$Time, n=1L), by=fill)
      aretirer <- -which(!is.na(match(newt, df$Time)))
      if (!identical(aretirer, integer(0))) newt <- newt[aretirer]
      df <- rbind(df, 
                  data.frame(Time=newt, TempC=NA, 
                             TempK=NA, R=NA, SCL=NA, IndiceK=NA)) 
      df <- df[order(df$Time),]
    }
    
    df <- cbind(df, DeltaT=c(diff(df$Time), 0))
    
    ind <- which(!is.na(df$TempC))      # get positions of nonmissing values
    if(is.na(df$TempC[1]))             # if it begins with a missing, add the 
      ind <- c(1,ind)        # first position to the indices
    df$TempC <- rep(df$TempC[ind], times = diff(   # repeat the values at these indices
      c(ind, length(df$TempC) + 1) ))
    df$TempK <- rep(df$TempK[ind], times = diff(   # repeat the values at these indices
      c(ind, length(df$TempK) + 1) ))
    df$IndiceK <- rep(df$IndiceK[ind], times = diff(   # repeat the values at these indices
      c(ind, length(df$IndiceK) + 1) ))
    
    df[1, "SCL"] <- M0
    return(df)
  })
  }
  
  
  # Je remplace le temperature_ec avec la nouvelle version
  temperatures_ec <- temperatures_ec2
  
  returntotal.summary <- list()
  returntotal.likelihood <- list()
  returntotal.metric <- list()
  
  if (progress) pb<-txtProgressBar(min=0, max=replicate.CI, style=3)

  SSM <- getFromNamespace(".SSM", ns="embryogrowth")
  
  for(sp in 1:replicate.CI) {
    if (progress) setTxtProgressBar(pb, sp)
    # sp <- 1      
    # if (sp==48) browser()
    #     print(sp)
    
    x <- as.numeric(df_random[sp, ])
    names(x) <- gsub("^X", "", colnames(df_random))
    if (!logicTransition) {
      transition_P <- x["transition_P"]
      transition_S <- x["transition_S"]
    } else {
      transition_P <- transition_S <- NULL
    }
    
    # Ce sont toutes les temperatures de tous les nids
    
    
    if (metabolic.heating == 0) {
      tempK <- as.numeric(temperatures[["Temperatures"]])
      rlist <- SSM(tempK, x)
      r <- rlist[[1]]
      r_L <- rlist[[2]]
    }
    
    
    if (!is.na(x["K"])) {
      Kval <- unname(x["K"])
    } else {
      Kval <- NULL
    }
    
    if (windows & parallel) {
      clusterExport(cl = cl, 
                    varlist=c("temperatures_ec", "temperature.heterogeneity", "test", 
                              "stopattest", "logicTransition", "metabolic.heating", 
                              "SSM", "x", "transition_S", "transition_P", 
                              "out", "Kval", "r", "r_L", "derivate", "metric.end.incubation", 
                              "size.begin.TSP", "size.end.TSP"), 
                    envir = environment())
      
      AnalyseTraces <- parLapply(cl=cl, X=name, function (xxx) {
        #      AnalyseTraces <- lapply(xx, function (xxx) {
        # xxx <- 1
        #       print(xxx)
        # dans df, j'ai la serie en cours de travail
        df <- temperatures_ec[[xxx]]
        # C'est maintenant directement xxx
        # namets <- names(temperatures_ec)[xxx]
        
        # 1/6/2016:
        if (length(temperature.heterogeneity)==1) 
          tht <- rnorm(1, 0, temperature.heterogeneity)
        else
          tht <- r2norm(1, 0, sd_low = temperature.heterogeneity[1], sd_high = temperature.heterogeneity[2])
        
        df[, "TempC"] <- df[, "TempC"] + tht
        df[, "TempK"] <- df[, "TempK"] + tht
        
        meanSCL <- as.numeric(test[xxx, "Mean"])
        sdSCL <- as.numeric(test[xxx, "SD"])
        
        if (is.na(meanSCL) | is.na(sdSCL)) stop("Check the test parameter. The size for time series does not exist.")
        
        if (!is.na(x["rK"])) {
          Kval <- unname(x["rK"]*meanSCL)
        }
        
        tmin <- df[, "Time"]
        
        ldt <- which(!is.na(df[, "TempC"]))
        
        # Si j'ai metabolic.heating != 0 ou tht != 0, je ne peux plus utiliser les index pour les r
        
        if ((metabolic.heating != 0) | (tht !=0)) {
          
          if (!stopattest) {
            if (logicTransition) {  
              for (i in 1:(length(ldt)-1)) {
                y <- df[ldt[i], "SCL"]
                range <- c(ldt[i]:ldt[i+1])
                timesunique <- tmin[range]
                df[ldt[i], "TempK"] <- df[ldt[i], "TempK"]+metabolic.heating*(y/meanSCL)
                a <- SSM(df[ldt[i], "TempK"], x)[[1]]
                param <- c(alpha=unname(a), K=Kval)
                out1 <- lsoda(y, timesunique, derivate, param)
                y <- as.numeric(tail(out1[,2], n=1))
                df[c(ldt[i]:(ldt[i+1]-1)), "R"] <- a
                df[range, "SCL"] <- out1[,2]
              }
              df[tail(ldt, 1), "TempK"] <- df[tail(ldt, 1), "TempK"] + metabolic.heating*(y/meanSCL)
              df[, "TempC"] <- df[, "TempK"] - 273.15
            } else {
              for (i in 1:(length(tmin)-1)) {
                y <- df[i, "SCL"]
                timesunique <- c(tmin[i], tmin[i+1])
                transition <- 1/(1+exp(transition_S*(y-transition_P)))
                df[ldt[i], "TempK"] <- df[ldt[i], "TempK"]+metabolic.heating*(y/meanSCL)
                rT <- SSM(df[ldt[i], "TempK"], x)
                a <- rT[[1]]*transition+rT[[2]]*(1-transition)
                param <- c(alpha=unname(a), K=Kval)
                out1 <- lsoda(y, timesunique, derivate, param)
                y <- as.numeric(tail(out1[,2], n=1))
                df[i, "R"] <- a
                df[i+1, "SCL"] <- y
              }
              df[tail(ldt, 1), "TempK"] <- df[tail(ldt, 1), "TempK"] + metabolic.heating*(y/meanSCL)
              df[, "TempC"] <- df[, "TempK"] - 273.15
            }
            # je suis en stopattest
          } else {
            if (logicTransition) {  
              for (i in 1:(length(ldt)-1)) {
                y <- df[ldt[i], "SCL"]
                range <- c(ldt[i]:ldt[i+1])
                timesunique <- tmin[range]
                df[ldt[i], "TempK"] <- df[ldt[i], "TempK"]+metabolic.heating*(y/meanSCL)
                a <- SSM(df[ldt[i], "TempK"], x)[[1]]
                param <- c(alpha=unname(a), K=Kval)
                out1 <- lsoda(y, timesunique, derivate, param)
                y <- as.numeric(tail(out1[,2], n=1))
                df[c(ldt[i]:(ldt[i+1]-1)), "R"] <- a
                df[range, "SCL"] <- out1[,2]
                if (y>meanSCL) {
                  df <- df[1:ldt[i+1], ]
                  df <- df[1:which(df[, "SCL"] >meanSCL)[1],]
                  y <- tail(df[, "SCL"], n=1)
                  break
                }
                df[tail(ldt, 1), "TempK"] <- df[tail(ldt, 1), "TempK"] + metabolic.heating*(y/meanSCL)
                df[, "TempC"] <- df[, "TempK"] - 273.15
              }
            } else {
              for (i in 1:(length(tmin)-1)) {
                y <- df[i, "SCL"]
                timesunique <- c(tmin[i], tmin[i+1])
                transition <- 1/(1+exp(transition_S*(y-transition_P)))
                df[ldt[i], "TempK"] <- df[ldt[i], "TempK"]+metabolic.heating*(y/meanSCL)
                rT <- SSM(df[ldt[i], "TempK"], x)
                a <- rT[[1]]*transition+rT[[2]]*(1-transition)
                param <- c(alpha=unname(a), K=Kval)
                out1 <- lsoda(y, timesunique, derivate, param)
                y <- as.numeric(tail(out1[,2], n=1))
                df[i, "R"] <- a
                df[i+1, "SCL"] <- y
                if (y>meanSCL) {
                  df <- df[1:(i+1), ]
                  df <- df[1:which(df[, "SCL"] >meanSCL)[1],]
                  y <- tail(df[, "SCL"], n=1)
                  break
                  # fin du if
                }
                # fin du for
              }
              df[tail(ldt, 1), "TempK"] <- df[tail(ldt, 1), "TempK"] + metabolic.heating*(y/meanSCL)
              df[, "TempC"] <- df[, "TempK"] - 273.15
              # fin du else logictransition
            }
            # fin du else !stopattest
          }
          
        } else {
          
          IndK <- df[, "IndiceK"]
          
          if (!stopattest) {
            if (logicTransition) {  
              for (i in 1:(length(ldt)-1)) {
                y <- df[ldt[i], "SCL"]
                range <- c(ldt[i]:ldt[i+1])
                timesunique <- tmin[range]
                a <- r[IndK[ldt[i]]]
                param <- c(alpha=unname(a), K=Kval)
                out1 <- lsoda(y, timesunique, derivate, param)
                y <- as.numeric(tail(out1[,2], n=1))
                df[c(ldt[i]:(ldt[i+1]-1)), "R"] <- a
                df[range, "SCL"] <- out1[,2]
              }
            } else {
              for (i in 1:(length(tmin)-1)) {
                y <- df[i, "SCL"]
                timesunique <- c(tmin[i], tmin[i+1])
                transition <- 1/(1+exp(transition_S*(y-transition_P)))
                if (!is.na(IndK[i])) tk <- IndK[i]
                a <- r[tk]*transition+r_L[tk]*(1-transition)
                param <- c(alpha=unname(a), K=Kval)
                out1 <- lsoda(y, timesunique, derivate, param)
                y <- as.numeric(tail(out1[,2], n=1))
                df[i, "R"] <- a
                df[i+1, "SCL"] <- y
              }
            }
            # je suis en stopattest
          } else {
            if (logicTransition) {  
              for (i in 1:(length(ldt)-1)) {
                y <- df[ldt[i], "SCL"]
                range <- c(ldt[i]:ldt[i+1])
                timesunique <- tmin[range]
                a <- r[IndK[ldt[i]]]
                param <- c(alpha=unname(a), K=Kval)
                out1 <- lsoda(y, timesunique, derivate, param)
                y <- as.numeric(tail(out1[,2], n=1))
                df[c(ldt[i]:(ldt[i+1]-1)), "R"] <- a
                df[range, "SCL"] <- out1[,2]
                if (y>meanSCL) {
                  df <- df[1:ldt[i+1], ]
                  df <- df[1:which(df[, "SCL"] >meanSCL)[1],]
                  y <- tail(df[, "SCL"], n=1)
                  break
                }
              }
            } else {
              for (i in 1:(length(tmin)-1)) {
                y <- df[i, "SCL"]
                timesunique <- c(tmin[i], tmin[i+1])
                transition <- 1/(1+exp(transition_S*(y-transition_P)))
                if (!is.na(IndK[i])) tk <- IndK[i]
                a <- r[tk]*transition+r_L[tk]*(1-transition)
                param <- c(alpha=unname(a), K=Kval)
                out1 <- lsoda(y, timesunique, derivate, param)
                y <- as.numeric(tail(out1[,2], n=1))
                df[i, "R"] <- a
                df[i+1, "SCL"] <- y
                if (y>meanSCL) {
                  df <- df[1:(i+1), ]
                  df <- df[1:which(df[, "SCL"] >meanSCL)[1],]
                  y <- tail(df[, "SCL"], n=1)
                  break
                  # fin du if
                }
                # fin du for
              }
              # fin du else logictransition
            }
            # fin du else !stopattest
          }
          # fin du else metabolic.heating
        }
        
        if (any(out=="likelihood")) {
          # dans y j'ai une valeur de taille finale
          # print(-dnorm(y, mean=meanSCL, sd=sdSCL, log=TRUE))
          return(-dnorm(y, mean=meanSCL, sd=sdSCL, log=TRUE))
        }
        
        
        #       if (out=="metric" | out=="summary") { 
        # si metric ou summary
        # les valeurs sont fausses pour transition
        
        # je suis sois en metric soit en summary
        
        ###############################
        #     indice.begin.tsp        #
        ###############################
        
        # 16/9/2015 Mme si je suis en stopattest, je prends la valeur finale si trop court        
        #       if (stopattest) {
        #          meanSCL_ec <- meanSCL
        #        } else {
        #          meanSCL_ec <- tail(df[,"SCL"], n=1)
        #        }
        
        meanSCL_ec <- y
        
        
        
        if (stopattest & meanSCL_ec <= meanSCL) {
          # warning(paste("Serie", xxx, "for replicate", sp, "stops before the mean hatchling metric"))
          retWrong <- FALSE
          attributes(retWrong)$error <- paste("Serie", xxx, "for replicate", sp, "stops before the mean hatchling metric")
          return(retWrong)
        }
        
        
        if (is.na(metric.end.incubation[xxx])) {
          size.begin.TSP_ec <- size.begin.TSP*meanSCL_ec
          size.end.TSP_ec <- size.end.TSP*meanSCL_ec
        } else {
          size.begin.TSP_ec <- size.begin.TSP*metric.end.incubation[xxx]
          size.end.TSP_ec <- size.end.TSP*metric.end.incubation[xxx]
        }
        
        df_ec <- df
        
        if (meanSCL_ec < size.begin.TSP_ec) {
          time.begin.TSP <- NA
          indice.begin.tsp <- NA
        } else {
          
          repeat {
            indice.begin.tsp <- which(df_ec[,"SCL"]>(size.begin.TSP_ec))[1]-1
            if (is.na(indice.begin.tsp)) break
            # la vrai TSP commence entre indice.begin.tsp et indice.begin.tsp+1
            timei1 <- df_ec[indice.begin.tsp,"Time"]+df_ec[indice.begin.tsp,"DeltaT"]*1/3
            timei2 <- df_ec[indice.begin.tsp,"Time"]+df_ec[indice.begin.tsp,"DeltaT"]*2/3
            timesunique <- c(df_ec[indice.begin.tsp, "Time"], timei1, timei2, df_ec[indice.begin.tsp+1, "Time"])
            # si je suis en transition, je dois recalculer R
            a <- df_ec[indice.begin.tsp, "R"]
            param <- c(alpha=unname(a), K=Kval)
            y <- df_ec[indice.begin.tsp, "SCL"]
            names(y) <- "SCL"
            dfpol <- lsoda(y, timesunique, derivate, param)
            df_ec <- data.frame(Time=timesunique, R=a, SCL=dfpol[,"SCL"])
            df_ec <- cbind(df_ec, DeltaT=c(diff(df_ec[, "Time"]), 0))
            if (df_ec[1, "DeltaT"]<1) break
          }
          indice.begin.tsp <- which(df_ec[,"SCL"]>(size.begin.TSP_ec))[1]-1
          if (is.na(indice.begin.tsp)) indice.begin.tsp <- 4
          time.begin.TSP <- df_ec[indice.begin.tsp,"Time"]
          indice.begin.tsp <- which(df[,"SCL"]>(size.begin.TSP_ec))[1]-1
        }
        
        ###############################
        #       indice.end.tsp        #
        ###############################
        
        df_ec <- df
        
        if (meanSCL_ec < size.end.TSP_ec) {
          time.end.TSP <- NA
          indice.end.tsp <- NA
        } else {
          
          repeat {
            indice.end.tsp <- which(df_ec[,"SCL"]>(size.end.TSP_ec))[1]-1
            if (is.na(indice.end.tsp)) break
            # la vrai TSP fini entre indice.end.tsp et indice.end.tsp+1
            timei1 <- df_ec[indice.end.tsp,"Time"]+df_ec[indice.end.tsp,"DeltaT"]*1/3
            timei2 <- df_ec[indice.end.tsp,"Time"]+df_ec[indice.end.tsp,"DeltaT"]*2/3
            timesunique <- c(df_ec[indice.end.tsp, "Time"], timei1, timei2, df_ec[indice.end.tsp+1, "Time"])
            # si je suis en transition, je dois recalculer R
            a <- df_ec[indice.end.tsp, "R"]
            param <- c(alpha=unname(a), K=Kval)
            y <- df_ec[indice.end.tsp, "SCL"]
            names(y) <- "SCL"
            dfpol <- lsoda(y, timesunique, derivate, param)
            df_ec <- data.frame(Time=timesunique, R=a, SCL=dfpol[,"SCL"])
            df_ec <- cbind(df_ec, DeltaT=c(diff(df_ec[, "Time"]), 0))
            if (df_ec[1, "DeltaT"]<1) break
          }
          indice.end.tsp <- which(df_ec[,"SCL"]>(size.end.TSP_ec))[1]-1
          if (is.na(indice.end.tsp)) indice.end.tsp <- 4
          time.end.TSP <- df_ec[indice.end.tsp,"Time"]
          indice.end.tsp <- which(df[,"SCL"]>(size.end.TSP_ec))[1]-1
        }
        
        
        # C'est necessaire pour estimer les temperatures moyennes
        # on doit les garder
        
        if (any(out=="summary")) {
          
          if (!is.na(indice.end.tsp) & !is.na(indice.begin.tsp)) {
            
            if (indice.begin.tsp!=indice.end.tsp)  {
              
              df <- rbind(df[1:indice.begin.tsp,], 
                          c(Time=time.begin.TSP, 
                            TempC=df[indice.begin.tsp,"TempC"], 
                            TempK=df[indice.begin.tsp,"TempK"], 
                            R=df[indice.begin.tsp,"R"], 
                            SCL=size.begin.TSP_ec, 
                            IndiceK=df[indice.begin.tsp,"IndiceK"], 
                            DeltaT=NA),
                          df[(indice.begin.tsp+1):indice.end.tsp,],
                          c(Time=time.end.TSP, 
                            TempC=df[indice.end.tsp,"TempC"], 
                            TempK=df[indice.end.tsp,"TempK"], 
                            R=df[indice.end.tsp,"R"], 
                            SCL=size.end.TSP_ec, 
                            IndiceK=df[indice.end.tsp,"IndiceK"], 
                            DeltaT=NA),
                          df[(indice.end.tsp+1):nrow(df),])
            } else {
              df <- rbind(df[1:indice.begin.tsp,], 
                          c(Time=time.begin.TSP, 
                            TempC=df[indice.begin.tsp,"TempC"], 
                            TempK=df[indice.begin.tsp,"TempK"], 
                            R=df[indice.begin.tsp,"R"], 
                            SCL=size.begin.TSP_ec, 
                            IndiceK=df[indice.begin.tsp,"IndiceK"], 
                            DeltaT=NA),
                          c(Time=time.end.TSP, 
                            TempC=df[indice.end.tsp,"TempC"], 
                            TempK=df[indice.end.tsp,"TempK"], 
                            R=df[indice.end.tsp,"R"], 
                            SCL=size.end.TSP_ec, 
                            IndiceK=df[indice.end.tsp,"IndiceK"], 
                            DeltaT=NA),
                          df[(indice.end.tsp+1):nrow(df),])
            }
            
            df[, "DeltaT"] <- c(diff(df[, "Time"]), 0)
          }
          
        }
        
        ###############################
        #   indice.fin.incubation     #
        ###############################
        # si je suis en stopattest, il faut que je calcule la vraie valeur de fin
        if (stopattest) {
          
          if (tail(df[,"SCL"], n=1L)>meanSCL) {
            attSAT <- TRUE
            df_ec <- df
            
            repeat {
              indice.fin.incubation <- which(df_ec[,"SCL"]>(meanSCL))[1]-1
              if (is.na(indice.fin.incubation)) break
              timei1 <- df_ec[indice.fin.incubation,"Time"]+df_ec[indice.fin.incubation,"DeltaT"]*1/3
              timei2 <- df_ec[indice.fin.incubation,"Time"]+df_ec[indice.fin.incubation,"DeltaT"]*2/3
              timesunique <- c(df_ec[indice.fin.incubation, "Time"], timei1, timei2, df_ec[indice.fin.incubation+1, "Time"])
              # si je suis en transition, je dois recalculer R
              a <- df_ec[indice.fin.incubation, "R"]
              param <- c(alpha=unname(a), K=Kval)
              y <- df_ec[indice.fin.incubation, "SCL"]
              names(y) <- "SCL"
              dfpol <- lsoda(y, timesunique, derivate, param)
              df_ec <- data.frame(Time=timesunique, R=a, SCL=dfpol[,"SCL"])
              df_ec <- cbind(df_ec, DeltaT=c(diff(df_ec[, "Time"]), 0))
              if (df_ec[1, "DeltaT"]<1) break
            }
            
            indice.end.incubation <- which(df_ec[,"SCL"]>(meanSCL))[1]-1
            if (is.na(indice.end.incubation)) indice.end.incubation <- 4
            time.end.incubation <- df_ec[indice.end.incubation,"Time"]
            indice.end.incubation <- which(df[,"SCL"]>(meanSCL))[1]-1
            
            # Maintenant je tronque df de faon  ne garder que jusqu'a time.end.incubation
            # garde
            df <- df[df[, "SCL"]<meanSCL,]
            df <- rbind(df, c(Time=time.end.incubation, 
                              TempC=tail(df$TempC, n=1L), tempK=tail(df$TempK, n=1L), 
                              R=NA, SCL=meanSCL, 
                              IndiceK=tail(df$IndiceK, n=1L), DeltaT=0))
            df[, "DeltaT"] <- c(diff(df[, "Time"]), 0)
          } else {attSAT <- FALSE}
        } else {attSAT <- NA}
        
        ###################################
        #    indice.begin.middlethird     #
        ###################################
        
        time.begin.middlethird <- (tail(df$Time, n=1L)-totpar["pipping_emergence"])*1/3
        indice.begin.middlethird <- which(df[,"Time"]>time.begin.middlethird)[1]-1
        # Je calcul la taille
        timesunique <- c(df[indice.begin.middlethird, "Time"], time.begin.middlethird, df[indice.begin.middlethird+1, "Time"])
        # si je suis en transition, je dois recalculer R
        a <- df[indice.begin.middlethird, "R"]
        param <- c(alpha=unname(a), K=Kval)
        y <- df[indice.begin.middlethird, "SCL"]
        names(y) <- "SCL"
        dfpol <- lsoda(y, timesunique, derivate, param)
        size.begin.middlethird <- dfpol[2, "SCL"]
        
        #################################
        #    indice.end.middlethird     #
        #################################
        
        time.end.middlethird <- (tail(df$Time, n=1L)-totpar["pipping_emergence"])*2/3
        indice.end.middlethird <- which(df[,"Time"]>time.end.middlethird)[1]-1
        # Je calcul la taille
        timesunique <- c(df[indice.end.middlethird, "Time"], time.end.middlethird, df[indice.end.middlethird+1, "Time"])
        # si je suis en transition, je dois recalculer R
        a <- df[indice.end.middlethird, "R"]
        param <- c(alpha=unname(a), K=Kval)
        y <- df[indice.end.middlethird, "SCL"]
        names(y) <- "SCL"
        dfpol <- lsoda(y, timesunique, derivate, param)
        size.end.middlethird <- dfpol[2, "SCL"]
        
        
        if (any(out=="summary")) {
          if (indice.begin.middlethird!=indice.end.middlethird) {
            
            df <- rbind(df[1:indice.begin.middlethird,], 
                        c(Time=time.begin.middlethird, 
                          TempC=df[indice.begin.middlethird,"TempC"], 
                          TempK=df[indice.begin.middlethird,"TempK"], 
                          R=df[indice.begin.middlethird,"R"], 
                          SCL=size.begin.middlethird, 
                          IndiceK=df[indice.begin.middlethird,"IndiceK"], 
                          DeltaT=NA),
                        df[(indice.begin.middlethird+1):indice.end.middlethird,],
                        c(Time=time.end.middlethird, 
                          TempC=df[indice.end.middlethird,"TempC"], 
                          TempK=df[indice.end.middlethird,"TempK"], 
                          R=df[indice.end.middlethird,"R"], 
                          SCL=size.end.middlethird, 
                          IndiceK=df[indice.end.middlethird,"IndiceK"], 
                          DeltaT=NA),
                        df[(indice.end.middlethird+1):nrow(df),])
          } else {
            df <- rbind(df[1:indice.begin.middlethird,], 
                        c(Time=time.begin.middlethird, 
                          TempC=df[indice.begin.middlethird,"TempC"], 
                          TempK=df[indice.begin.middlethird,"TempK"], 
                          R=df[indice.begin.middlethird,"R"], 
                          SCL=size.begin.middlethird, 
                          IndiceK=df[indice.begin.middlethird,"IndiceK"], 
                          DeltaT=NA),
                        c(Time=time.end.middlethird, 
                          TempC=df[indice.end.middlethird,"TempC"], 
                          TempK=df[indice.end.middlethird,"TempK"], 
                          R=df[indice.end.middlethird,"R"], 
                          SCL=size.end.middlethird, 
                          IndiceK=df[indice.end.middlethird,"IndiceK"], 
                          DeltaT=NA),
                        df[(indice.end.middlethird+1):nrow(df),])
          }
          
          df[,"DeltaT"] <- c(diff(df[,"Time"]), 0)
        }
        
        #######################
        # fin des indices     #
        #######################                        
        
        rownames(df) <- 1:nrow(df)
        if (any(out=="summary")) {
          attributes(df)$indice.end.tsp <- which(df[, "Time"]==time.end.TSP)[1]
          attributes(df)$indice.begin.tsp <- which(df[, "Time"]==time.begin.TSP)[1]
          attributes(df)$indice.begin.middlethird <- which(df[, "Time"]==time.begin.middlethird)[1]
          attributes(df)$indice.end.middlethird <- which(df[, "Time"]==time.end.middlethird)[1]
        }
        attributes(df)$metric.begin.tsp <- size.begin.TSP_ec
        attributes(df)$metric.end.tsp <-  size.end.TSP_ec
        attributes(df)$test.mean <- meanSCL
        attributes(df)$test.sd <- sdSCL
        attributes(df)$time.end.tsp <- time.end.TSP
        attributes(df)$time.begin.tsp <- time.begin.TSP
        attributes(df)$metric.end.incubation <- metric.end.incubation[xxx]
        attributes(df)$time.begin.middlethird <- time.begin.middlethird
        attributes(df)$time.end.middlethird <- time.end.middlethird
        attributes(df)$stopattest <- attSAT
        return(df)
        # fin de si metric ou summary
        #        }
        # fin du mcapply
      })
      
      stopCluster(cl)
      
      
      
    } else {
    
      # Je suis sur un système UNIX
      
    AnalyseTraces <- mclapply(mc.cores = papply, X=name, function (xxx) {
      #      AnalyseTraces <- lapply(xx, function (xxx) {
      # xxx <- 1
      #       print(xxx)
      # dans df, j'ai la serie en cours de travail
      df <- temperatures_ec[[xxx]]
      # C'est maintenant directement xxx
      # namets <- names(temperatures_ec)[xxx]
      
      # 1/6/2016:
      
      if (length(temperature.heterogeneity)==1) {
        tht <- 0
        if (temperature.heterogeneity !=0) tht <- rnorm(1, 0, temperature.heterogeneity)
      } else {
        tht <- r2norm(1, 0, sd_low = temperature.heterogeneity[1], sd_high = temperature.heterogeneity[2])
      }
      
      df[, "TempC"] <- df[, "TempC"] + tht
      df[, "TempK"] <- df[, "TempK"] + tht
      
      meanSCL <- as.numeric(test[xxx, "Mean"])
      sdSCL <- as.numeric(test[xxx, "SD"])
      
      if (is.na(meanSCL)) stop("Check the test parameter. The size for time series does not exist.")
      
      if (!is.na(x["rK"])) {
        Kval <- unname(x["rK"]*meanSCL)
      }
      
      tmin <- df[, "Time"]
      
      ldt <- which(!is.na(df[, "TempC"]))
      
      # Si j'ai metabolic.heating != 0 ou tht != 0, je ne peux plus utiliser les index pour les r
      
      if ((metabolic.heating != 0) | (tht !=0)) {
        
        if (!stopattest) {
          if (logicTransition) {  
            for (i in 1:(length(ldt)-1)) {
              y <- df[ldt[i], "SCL"]
              range <- c(ldt[i]:ldt[i+1])
              timesunique <- tmin[range]
              df[ldt[i], "TempK"] <- df[ldt[i], "TempK"]+metabolic.heating*(y/meanSCL)
              a <- SSM(df[ldt[i], "TempK"], x)[[1]]
              param <- c(alpha=unname(a), K=Kval)
              out1 <- lsoda(y, timesunique, derivate, param)
              y <- as.numeric(tail(out1[,2], n=1))
              df[c(ldt[i]:(ldt[i+1]-1)), "R"] <- a
              df[range, "SCL"] <- out1[,2]
            }
            df[tail(ldt, 1), "TempK"] <- df[tail(ldt, 1), "TempK"] + metabolic.heating*(y/meanSCL)
            df[, "TempC"] <- df[, "TempK"] - 273.15
          } else {
            for (i in 1:(length(tmin)-1)) {
              y <- df[i, "SCL"]
              timesunique <- c(tmin[i], tmin[i+1])
              transition <- 1/(1+exp(transition_S*(y-transition_P)))
              df[ldt[i], "TempK"] <- df[ldt[i], "TempK"]+metabolic.heating*(y/meanSCL)
              rT <- SSM(df[ldt[i], "TempK"], x)
              a <- rT[[1]]*transition+rT[[2]]*(1-transition)
              param <- c(alpha=unname(a), K=Kval)
              out1 <- lsoda(y, timesunique, derivate, param)
              y <- as.numeric(tail(out1[,2], n=1))
              df[i, "R"] <- a
              df[i+1, "SCL"] <- y
            }
            df[tail(ldt, 1), "TempK"] <- df[tail(ldt, 1), "TempK"] + metabolic.heating*(y/meanSCL)
            df[, "TempC"] <- df[, "TempK"] - 273.15
          }
          # je suis en stopattest
        } else {
          if (logicTransition) {  
            for (i in 1:(length(ldt)-1)) {
              y <- df[ldt[i], "SCL"]
              range <- c(ldt[i]:ldt[i+1])
              timesunique <- tmin[range]
              df[ldt[i], "TempK"] <- df[ldt[i], "TempK"]+metabolic.heating*(y/meanSCL)
              a <- SSM(df[ldt[i], "TempK"], x)[[1]]
              param <- c(alpha=unname(a), K=Kval)
              out1 <- lsoda(y, timesunique, derivate, param)
              y <- as.numeric(tail(out1[,2], n=1))
              df[c(ldt[i]:(ldt[i+1]-1)), "R"] <- a
              df[range, "SCL"] <- out1[,2]
              if (y>meanSCL) {
                df <- df[1:ldt[i+1], ]
                df <- df[1:which(df[, "SCL"] >meanSCL)[1],]
                y <- tail(df[, "SCL"], n=1)
                break
              }
              df[tail(ldt, 1), "TempK"] <- df[tail(ldt, 1), "TempK"] + metabolic.heating*(y/meanSCL)
              df[, "TempC"] <- df[, "TempK"] - 273.15
            }
          } else {
            for (i in 1:(length(tmin)-1)) {
              y <- df[i, "SCL"]
              timesunique <- c(tmin[i], tmin[i+1])
              transition <- 1/(1+exp(transition_S*(y-transition_P)))
              df[ldt[i], "TempK"] <- df[ldt[i], "TempK"]+metabolic.heating*(y/meanSCL)
              rT <- SSM(df[ldt[i], "TempK"], x)
              a <- rT[[1]]*transition+rT[[2]]*(1-transition)
              param <- c(alpha=unname(a), K=Kval)
              out1 <- lsoda(y, timesunique, derivate, param)
              y <- as.numeric(tail(out1[,2], n=1))
              df[i, "R"] <- a
              df[i+1, "SCL"] <- y
              if (y>meanSCL) {
                df <- df[1:(i+1), ]
                df <- df[1:which(df[, "SCL"] >meanSCL)[1],]
                y <- tail(df[, "SCL"], n=1)
                break
                # fin du if
              }
              # fin du for
            }
            df[tail(ldt, 1), "TempK"] <- df[tail(ldt, 1), "TempK"] + metabolic.heating*(y/meanSCL)
            df[, "TempC"] <- df[, "TempK"] - 273.15
            # fin du else logictransition
          }
          # fin du else !stopattest
        }
        
      } else {
        
        IndK <- df[, "IndiceK"]
        
        if (!stopattest) {
          if (logicTransition) {  
            for (i in 1:(length(ldt)-1)) {
              y <- df[ldt[i], "SCL"]
              range <- c(ldt[i]:ldt[i+1])
              timesunique <- tmin[range]
              a <- r[IndK[ldt[i]]]
              param <- c(alpha=unname(a), K=Kval)
              out1 <- lsoda(y, timesunique, derivate, param)
              y <- as.numeric(tail(out1[,2], n=1))
              df[c(ldt[i]:(ldt[i+1]-1)), "R"] <- a
              df[range, "SCL"] <- out1[,2]
            }
          } else {
            for (i in 1:(length(tmin)-1)) {
              y <- df[i, "SCL"]
              timesunique <- c(tmin[i], tmin[i+1])
              transition <- 1/(1+exp(transition_S*(y-transition_P)))
              if (!is.na(IndK[i])) tk <- IndK[i]
              a <- r[tk]*transition+r_L[tk]*(1-transition)
              param <- c(alpha=unname(a), K=Kval)
              out1 <- lsoda(y, timesunique, derivate, param)
              y <- as.numeric(tail(out1[,2], n=1))
              df[i, "R"] <- a
              df[i+1, "SCL"] <- y
            }
          }
          # je suis en stopattest
        } else {
          if (logicTransition) {  
            for (i in 1:(length(ldt)-1)) {
              y <- df[ldt[i], "SCL"]
              range <- c(ldt[i]:ldt[i+1])
              timesunique <- tmin[range]
              a <- r[IndK[ldt[i]]]
              param <- c(alpha=unname(a), K=Kval)
              out1 <- lsoda(y, timesunique, derivate, param)
              y <- as.numeric(tail(out1[,2], n=1))
              df[c(ldt[i]:(ldt[i+1]-1)), "R"] <- a
              df[range, "SCL"] <- out1[,2]
              if (y>meanSCL) {
                df <- df[1:ldt[i+1], ]
                df <- df[1:which(df[, "SCL"] >meanSCL)[1],]
                y <- tail(df[, "SCL"], n=1)
                break
              }
            }
          } else {
            for (i in 1:(length(tmin)-1)) {
              y <- df[i, "SCL"]
              timesunique <- c(tmin[i], tmin[i+1])
              transition <- 1/(1+exp(transition_S*(y-transition_P)))
              if (!is.na(IndK[i])) tk <- IndK[i]
              a <- r[tk]*transition+r_L[tk]*(1-transition)
              param <- c(alpha=unname(a), K=Kval)
              out1 <- lsoda(y, timesunique, derivate, param)
              y <- as.numeric(tail(out1[,2], n=1))
              df[i, "R"] <- a
              df[i+1, "SCL"] <- y
              if (y>meanSCL) {
                df <- df[1:(i+1), ]
                df <- df[1:which(df[, "SCL"] >meanSCL)[1],]
                y <- tail(df[, "SCL"], n=1)
                break
                # fin du if
              }
              # fin du for
            }
            # fin du else logictransition
          }
          # fin du else !stopattest
        }
        # fin du else metabolic.heating
      }
      
      if (any(out=="likelihood")) {
        # dans y j'ai une valeur de taille finale
        # print(-dnorm(y, mean=meanSCL, sd=sdSCL, log=TRUE))
        if (!is.na(sdSCL)) {
          return(-dnorm(y, mean=meanSCL, sd=sdSCL, log=TRUE))
        } else {
          return((y-meanSCL)^2)
        }
      }
      
      
      #       if (out=="metric" | out=="summary") { 
      # si metric ou summary
      # les valeurs sont fausses pour transition
      
      # je suis sois en metric soit en summary
      
      ###############################
      #     indice.begin.tsp        #
      ###############################
      
      # 16/9/2015 Mme si je suis en stopattest, je prends la valeur finale si trop court        
      #       if (stopattest) {
      #          meanSCL_ec <- meanSCL
      #        } else {
      #          meanSCL_ec <- tail(df[,"SCL"], n=1)
      #        }
      
      meanSCL_ec <- y
      
      
      
      if (stopattest & meanSCL_ec <= meanSCL) {
        # warning(paste("Serie", xxx, "for replicate", sp, "stops before the mean hatchling metric"))
        retWrong <- FALSE
        attributes(retWrong)$error <- paste("Serie", xxx, "for replicate", sp, "stops before the mean hatchling metric")
        return(retWrong)
      }
      
      
      if (is.na(metric.end.incubation[xxx])) {
        size.begin.TSP_ec <- size.begin.TSP*meanSCL_ec
        size.end.TSP_ec <- size.end.TSP*meanSCL_ec
      } else {
        size.begin.TSP_ec <- size.begin.TSP*metric.end.incubation[xxx]
        size.end.TSP_ec <- size.end.TSP*metric.end.incubation[xxx]
      }
      
      df_ec <- df
      
      if (meanSCL_ec < size.begin.TSP_ec) {
        time.begin.TSP <- NA
        indice.begin.tsp <- NA
      } else {
        
        repeat {
          indice.begin.tsp <- which(df_ec[,"SCL"]>(size.begin.TSP_ec))[1]-1
          if (is.na(indice.begin.tsp)) break
          # la vrai TSP commence entre indice.begin.tsp et indice.begin.tsp+1
          timei1 <- df_ec[indice.begin.tsp,"Time"]+df_ec[indice.begin.tsp,"DeltaT"]*1/3
          timei2 <- df_ec[indice.begin.tsp,"Time"]+df_ec[indice.begin.tsp,"DeltaT"]*2/3
          timesunique <- c(df_ec[indice.begin.tsp, "Time"], timei1, timei2, df_ec[indice.begin.tsp+1, "Time"])
          # si je suis en transition, je dois recalculer R
          a <- df_ec[indice.begin.tsp, "R"]
          param <- c(alpha=unname(a), K=Kval)
          y <- df_ec[indice.begin.tsp, "SCL"]
          names(y) <- "SCL"
          dfpol <- lsoda(y, timesunique, derivate, param)
          df_ec <- data.frame(Time=timesunique, R=a, SCL=dfpol[,"SCL"])
          df_ec <- cbind(df_ec, DeltaT=c(diff(df_ec[, "Time"]), 0))
          if (df_ec[1, "DeltaT"]<1) break
        }
        indice.begin.tsp <- which(df_ec[,"SCL"]>(size.begin.TSP_ec))[1]-1
        if (is.na(indice.begin.tsp)) indice.begin.tsp <- 4
        time.begin.TSP <- df_ec[indice.begin.tsp,"Time"]
        indice.begin.tsp <- which(df[,"SCL"]>(size.begin.TSP_ec))[1]-1
      }
      
      ###############################
      #       indice.end.tsp        #
      ###############################
      
      df_ec <- df
      
      if (meanSCL_ec < size.end.TSP_ec) {
        time.end.TSP <- NA
        indice.end.tsp <- NA
      } else {
        
        repeat {
          indice.end.tsp <- which(df_ec[,"SCL"]>(size.end.TSP_ec))[1]-1
          if (is.na(indice.end.tsp)) break
          # la vrai TSP fini entre indice.end.tsp et indice.end.tsp+1
          timei1 <- df_ec[indice.end.tsp,"Time"]+df_ec[indice.end.tsp,"DeltaT"]*1/3
          timei2 <- df_ec[indice.end.tsp,"Time"]+df_ec[indice.end.tsp,"DeltaT"]*2/3
          timesunique <- c(df_ec[indice.end.tsp, "Time"], timei1, timei2, df_ec[indice.end.tsp+1, "Time"])
          # si je suis en transition, je dois recalculer R
          a <- df_ec[indice.end.tsp, "R"]
          param <- c(alpha=unname(a), K=Kval)
          y <- df_ec[indice.end.tsp, "SCL"]
          names(y) <- "SCL"
          dfpol <- lsoda(y, timesunique, derivate, param)
          df_ec <- data.frame(Time=timesunique, R=a, SCL=dfpol[,"SCL"])
          df_ec <- cbind(df_ec, DeltaT=c(diff(df_ec[, "Time"]), 0))
          if (df_ec[1, "DeltaT"]<1) break
        }
        indice.end.tsp <- which(df_ec[,"SCL"]>(size.end.TSP_ec))[1]-1
        if (is.na(indice.end.tsp)) indice.end.tsp <- 4
        time.end.TSP <- df_ec[indice.end.tsp,"Time"]
        indice.end.tsp <- which(df[,"SCL"]>(size.end.TSP_ec))[1]-1
      }
      
      
      # C'est necessaire pour estimer les temperatures moyennes
      # on doit les garder
      
      if (any(out=="summary")) {
        
        if (!is.na(indice.end.tsp) & !is.na(indice.begin.tsp)) {
          
          if (indice.begin.tsp!=indice.end.tsp)  {
            
            df <- rbind(df[1:indice.begin.tsp,], 
                        c(Time=time.begin.TSP, 
                          TempC=df[indice.begin.tsp,"TempC"], 
                          TempK=df[indice.begin.tsp,"TempK"], 
                          R=df[indice.begin.tsp,"R"], 
                          SCL=size.begin.TSP_ec, 
                          IndiceK=df[indice.begin.tsp,"IndiceK"], 
                          DeltaT=NA),
                        df[(indice.begin.tsp+1):indice.end.tsp,],
                        c(Time=time.end.TSP, 
                          TempC=df[indice.end.tsp,"TempC"], 
                          TempK=df[indice.end.tsp,"TempK"], 
                          R=df[indice.end.tsp,"R"], 
                          SCL=size.end.TSP_ec, 
                          IndiceK=df[indice.end.tsp,"IndiceK"], 
                          DeltaT=NA),
                        df[(indice.end.tsp+1):nrow(df),])
          } else {
            df <- rbind(df[1:indice.begin.tsp,], 
                        c(Time=time.begin.TSP, 
                          TempC=df[indice.begin.tsp,"TempC"], 
                          TempK=df[indice.begin.tsp,"TempK"], 
                          R=df[indice.begin.tsp,"R"], 
                          SCL=size.begin.TSP_ec, 
                          IndiceK=df[indice.begin.tsp,"IndiceK"], 
                          DeltaT=NA),
                        c(Time=time.end.TSP, 
                          TempC=df[indice.end.tsp,"TempC"], 
                          TempK=df[indice.end.tsp,"TempK"], 
                          R=df[indice.end.tsp,"R"], 
                          SCL=size.end.TSP_ec, 
                          IndiceK=df[indice.end.tsp,"IndiceK"], 
                          DeltaT=NA),
                        df[(indice.end.tsp+1):nrow(df),])
          }
          
          df[, "DeltaT"] <- c(diff(df[, "Time"]), 0)
        }
        
      }
      
      ###############################
      #   indice.fin.incubation     #
      ###############################
      # si je suis en stopattest, il faut que je calcule la vraie valeur de fin
      if (stopattest) {
        
        if (tail(df[,"SCL"], n=1L)>meanSCL) {
          attSAT <- TRUE
          df_ec <- df
          
          repeat {
            indice.fin.incubation <- which(df_ec[,"SCL"]>(meanSCL))[1]-1
            if (is.na(indice.fin.incubation)) break
            timei1 <- df_ec[indice.fin.incubation,"Time"]+df_ec[indice.fin.incubation,"DeltaT"]*1/3
            timei2 <- df_ec[indice.fin.incubation,"Time"]+df_ec[indice.fin.incubation,"DeltaT"]*2/3
            timesunique <- c(df_ec[indice.fin.incubation, "Time"], timei1, timei2, df_ec[indice.fin.incubation+1, "Time"])
            # si je suis en transition, je dois recalculer R
            a <- df_ec[indice.fin.incubation, "R"]
            param <- c(alpha=unname(a), K=Kval)
            y <- df_ec[indice.fin.incubation, "SCL"]
            names(y) <- "SCL"
            dfpol <- lsoda(y, timesunique, derivate, param)
            df_ec <- data.frame(Time=timesunique, R=a, SCL=dfpol[,"SCL"])
            df_ec <- cbind(df_ec, DeltaT=c(diff(df_ec[, "Time"]), 0))
            if (df_ec[1, "DeltaT"]<1) break
          }
          
          indice.end.incubation <- which(df_ec[,"SCL"]>(meanSCL))[1]-1
          if (is.na(indice.end.incubation)) indice.end.incubation <- 4
          time.end.incubation <- df_ec[indice.end.incubation,"Time"]
          indice.end.incubation <- which(df[,"SCL"]>(meanSCL))[1]-1
          
          # Maintenant je tronque df de faon  ne garder que jusqu'a time.end.incubation
          # garde
          df <- df[df[, "SCL"]<meanSCL,]
          df <- rbind(df, c(Time=time.end.incubation, 
                            TempC=tail(df$TempC, n=1L), tempK=tail(df$TempK, n=1L), 
                            R=NA, SCL=meanSCL, 
                            IndiceK=tail(df$IndiceK, n=1L), DeltaT=0))
          df[, "DeltaT"] <- c(diff(df[, "Time"]), 0)
        } else {attSAT <- FALSE}
      } else {attSAT <- NA}
      
      ###################################
      #    indice.begin.middlethird     #
      ###################################
      
      time.begin.middlethird <- (tail(df$Time, n=1L)-totpar["pipping_emergence"])*1/3
      indice.begin.middlethird <- which(df[,"Time"]>time.begin.middlethird)[1]-1
      # Je calcul la taille
      timesunique <- c(df[indice.begin.middlethird, "Time"], time.begin.middlethird, df[indice.begin.middlethird+1, "Time"])
      # si je suis en transition, je dois recalculer R
      a <- df[indice.begin.middlethird, "R"]
      param <- c(alpha=unname(a), K=Kval)
      y <- df[indice.begin.middlethird, "SCL"]
      names(y) <- "SCL"
      dfpol <- lsoda(y, timesunique, derivate, param)
      size.begin.middlethird <- dfpol[2, "SCL"]
      
      #################################
      #    indice.end.middlethird     #
      #################################
      
      time.end.middlethird <- (tail(df$Time, n=1L)-totpar["pipping_emergence"])*2/3
      indice.end.middlethird <- which(df[,"Time"]>time.end.middlethird)[1]-1
      # Je calcul la taille
      timesunique <- c(df[indice.end.middlethird, "Time"], time.end.middlethird, df[indice.end.middlethird+1, "Time"])
      # si je suis en transition, je dois recalculer R
      a <- df[indice.end.middlethird, "R"]
      param <- c(alpha=unname(a), K=Kval)
      y <- df[indice.end.middlethird, "SCL"]
      names(y) <- "SCL"
      dfpol <- lsoda(y, timesunique, derivate, param)
      size.end.middlethird <- dfpol[2, "SCL"]
      
      
      if (any(out=="summary")) {
        if (indice.begin.middlethird!=indice.end.middlethird) {
          
          df <- rbind(df[1:indice.begin.middlethird,], 
                      c(Time=time.begin.middlethird, 
                        TempC=df[indice.begin.middlethird,"TempC"], 
                        TempK=df[indice.begin.middlethird,"TempK"], 
                        R=df[indice.begin.middlethird,"R"], 
                        SCL=size.begin.middlethird, 
                        IndiceK=df[indice.begin.middlethird,"IndiceK"], 
                        DeltaT=NA),
                      df[(indice.begin.middlethird+1):indice.end.middlethird,],
                      c(Time=time.end.middlethird, 
                        TempC=df[indice.end.middlethird,"TempC"], 
                        TempK=df[indice.end.middlethird,"TempK"], 
                        R=df[indice.end.middlethird,"R"], 
                        SCL=size.end.middlethird, 
                        IndiceK=df[indice.end.middlethird,"IndiceK"], 
                        DeltaT=NA),
                      df[(indice.end.middlethird+1):nrow(df),])
        } else {
          df <- rbind(df[1:indice.begin.middlethird,], 
                      c(Time=time.begin.middlethird, 
                        TempC=df[indice.begin.middlethird,"TempC"], 
                        TempK=df[indice.begin.middlethird,"TempK"], 
                        R=df[indice.begin.middlethird,"R"], 
                        SCL=size.begin.middlethird, 
                        IndiceK=df[indice.begin.middlethird,"IndiceK"], 
                        DeltaT=NA),
                      c(Time=time.end.middlethird, 
                        TempC=df[indice.end.middlethird,"TempC"], 
                        TempK=df[indice.end.middlethird,"TempK"], 
                        R=df[indice.end.middlethird,"R"], 
                        SCL=size.end.middlethird, 
                        IndiceK=df[indice.end.middlethird,"IndiceK"], 
                        DeltaT=NA),
                      df[(indice.end.middlethird+1):nrow(df),])
        }
        
        df[,"DeltaT"] <- c(diff(df[,"Time"]), 0)
      }
      
      #######################
      # fin des indices     #
      #######################                        
      
      rownames(df) <- 1:nrow(df)
      if (any(out=="summary")) {
        attributes(df)$indice.end.tsp <- which(df[, "Time"]==time.end.TSP)[1]
        attributes(df)$indice.begin.tsp <- which(df[, "Time"]==time.begin.TSP)[1]
        attributes(df)$indice.begin.middlethird <- which(df[, "Time"]==time.begin.middlethird)[1]
        attributes(df)$indice.end.middlethird <- which(df[, "Time"]==time.end.middlethird)[1]
      }
      attributes(df)$metric.begin.tsp <- size.begin.TSP_ec
      attributes(df)$metric.end.tsp <-  size.end.TSP_ec
      attributes(df)$test.mean <- meanSCL
      attributes(df)$test.sd <- sdSCL
      attributes(df)$time.end.tsp <- time.end.TSP
      attributes(df)$time.begin.tsp <- time.begin.TSP
      attributes(df)$metric.end.incubation <- metric.end.incubation[xxx]
      attributes(df)$time.begin.middlethird <- time.begin.middlethird
      attributes(df)$time.end.middlethird <- time.end.middlethird
      attributes(df)$stopattest <- attSAT
      return(df)
      # fin de si metric ou summary
      #        }
      # fin du mcapply
    })
    
    }
    
    
    
    if (any(out=="likelihood")) {
      L <- unlist(AnalyseTraces)
      # names(L) <- names(AnalyseTraces)
      # dans L j'ai un vecteur avec le nom
      # il faut que j'applique le weight
      if (!is.null(weight))	L <- L*weight[names(L)]
      returntotal.likelihood <- (sum(L))
    }
    
    if (any(out=="metric")) {
      returntotal.metric <- c(returntotal.metric, list(AnalyseTraces))
    }
    
    if (any(out=="summary")) {
      
      if (any(unlist(lapply(AnalyseTraces, function(x) {attributes(x) <- NULL; identical(x = x, y=FALSE)})))) {
        if (warnings) warning("replicate ", sp, ": Something goes wrong")
        summarydf <- data.frame(
          TimeWeighted.temperature.mean=NA,
          MassWeighted.temperature.mean=NA,
          TSP.TimeWeighted.temperature.mean=NA,
          TSP.MassWeighted.temperature.mean=NA,
          TSP.STRNWeighted.temperature.mean=NA,
          TSP.MassWeighted.STRNWeighted.temperature.mean=NA,
          TSP.length.mean=NA,
          TSP.begin.mean=NA,
          TSP.end.mean=NA,
          Incubation.length.mean=NA,
          Middlethird.length.mean=NA,
          Middlethird.begin.mean=NA,
          Middlethird.end.mean=NA,
          MiddleThird.TimeWeighted.temperature.mean=NA,
          MiddleThird.MassWeighted.temperature.mean=NA, 
          CTEA.TSP_CTEA.2ndT=NA, 
          CTEW.TSP_CTEW.2ndT=NA
        )
        returntotal.summary <- c(returntotal.summary, list(summarydf))
      } else {
        
        TimeWeighted.temperature.mean <- unlist(lapply(AnalyseTraces, function(x) sum(x[, "TempC"]*x[, "DeltaT"])/sum(x[, "DeltaT"])))
        MassWeighted.temperature.mean <- unlist(lapply(AnalyseTraces, 
                                                       function(x) {
                                                         x2 <- x[, "TempC"]
                                                         dSCL <- c(diff(x[, "SCL"]), 0)
                                                         sum(x2*dSCL)/sum(dSCL)
                                                       }))
        TSP.TimeWeighted.temperature.mean <- unlist(lapply(AnalyseTraces, 
                                                           function(x) {
                                                             if (!is.na(attributes(x)$indice.begin.tsp) & !is.na(attributes(x)$indice.end.tsp)) {
                                                               x2 <- x[(attributes(x)$indice.begin.tsp):(attributes(x)$indice.end.tsp-1), ]
                                                               sum(x2[, "TempC"]*x2[, "DeltaT"])/sum(x2[, "DeltaT"])
                                                             } else {NA}
                                                           }))
        TSP.MassWeighted.temperature.mean <- unlist(lapply(AnalyseTraces, 
                                                           function(x) {
                                                             if (!is.na(attributes(x)$indice.begin.tsp) & !is.na(attributes(x)$indice.end.tsp)) {
                                                               x2 <- x[(attributes(x)$indice.begin.tsp):(attributes(x)$indice.end.tsp-1), "TempC"]
                                                               dSCL <- c(diff(x[, "SCL"]), 0)[(attributes(x)$indice.begin.tsp):(attributes(x)$indice.end.tsp-1)]
                                                               sum(x2*dSCL)/sum(dSCL)
                                                             } else {NA}
                                                           }))
        if (is.null(SexualisationTRN)) {
          TSP.STRNWeighted.temperature.mean <- rep(NA, length(AnalyseTraces))
          names(TSP.STRNWeighted.temperature.mean) <- name
          TSP.MassWeighted.STRNWeighted.temperature.mean <- rep(NA, length(AnalyseTraces))
          names(TSP.MassWeighted.STRNWeighted.temperature.mean) <- name
        } else {
          if (SexualisationTRN.CI=="null") {
            STRN <- c(SexualisationTRN, SexualisationTRN.fixed.parameters)
          }
          if (SexualisationTRN.CI=="hessian") {
            # pre0.9_9994 = FALSE
            dataR <- matrix(rnorm(1 * ncol(sigma.STRN)), nrow = 1, byrow = TRUE) %*% R.STRN
            dataR <- sweep(dataR, 2, SexualisationTRN[rownames(SexualisationTRN.hessian)], "+")
            colnames(dataR) <- rownames(SexualisationTRN.hessian)
            
            STRN <- c(SexualisationTRN.fixed.parameters, dataR[1, ])
          }
          if (SexualisationTRN.CI=="mcmc") {
            STRN <- c(SexualisationTRN.fixed.parameters, 
                      SexualisationTRN.mcmc$resultMCMC[[1]][floor(runif(n=1, min=1, max = nrSTRN+1)), ])
          }
          if (SexualisationTRN.CI=="se") {
            STRN <- c(SexualisationTRN, SexualisationTRN.fixed.parameters)
            nSE.STRN <- names(SexualisationTRN.SE)
            STRN <- c(structure(rnorm(length(nSE.STRN), STRN[nSE.STRN], SexualisationTRN.SE), 
                                .Names=nSE.STRN), 
                      STRN[!(names(STRN) %in% nSE.STRN)])
          }
          
          TSP.STRNWeighted.temperature.mean <- unlist(lapply(AnalyseTraces, 
                                                             function(x) {
                                                               if (!is.na(attributes(x)$indice.begin.tsp) & !is.na(attributes(x)$indice.end.tsp)) {
                                                                 # dans x[, "TempC"] j'ai les temperatures en Celsius
                                                                 x2 <- x[(attributes(x)$indice.begin.tsp):(attributes(x)$indice.end.tsp-1), ]
                                                                 
                                                                 STRN_model <- getFromNamespace(".SSM", ns="embryogrowth")(x2[, "TempK"], STRN)[[1]]
                                                                 sum(x2[, "TempC"]*x2[, "DeltaT"]*STRN_model)/sum(x2[, "DeltaT"]*STRN_model)
                                                               } else {NA}
                                                             }))
          
          TSP.MassWeighted.STRNWeighted.temperature.mean <- unlist(lapply(AnalyseTraces, 
                                                                          function(x) {
                                                                            if (!is.na(attributes(x)$indice.begin.tsp) & !is.na(attributes(x)$indice.end.tsp)) {
                                                                              # dans x[, "TempC"] j'ai les temperatures en Celsius
                                                                              x2 <- x[(attributes(x)$indice.begin.tsp):(attributes(x)$indice.end.tsp-1), ]
                                                                              
                                                                              STRN_model <- getFromNamespace(".SSM", ns="embryogrowth")(x2[, "TempK"], STRN)[[1]]
                                                                              dSCL <- c(diff(x[, "SCL"]), 0)[(attributes(x)$indice.begin.tsp):(attributes(x)$indice.end.tsp-1)]
                                                                              sum(x2[, "TempC"]*dSCL*STRN_model)/sum(dSCL*STRN_model)
                                                                            } else {NA}
                                                                          }))
        }
        
        TSP.length.mean <- unlist(lapply(AnalyseTraces, 
                                         function(x) {
                                           if (!is.na(attributes(x)$indice.begin.tsp) & !is.na(attributes(x)$indice.end.tsp)) {
                                             t1 <- attributes(x)$time.begin.tsp
                                             t2 <- attributes(x)$time.end.tsp
                                             return(t2-t1)
                                           } else {NA}
                                         }))
        TSP.begin.mean <- unlist(lapply(AnalyseTraces, 
                                        function(x) {
                                          return(attributes(x)$time.begin.tsp)
                                        }))
        TSP.end.mean <- unlist(lapply(AnalyseTraces, 
                                      function(x) {
                                        return(attributes(x)$time.end.tsp)
                                      }))
        Middlethird.length.mean <- unlist(lapply(AnalyseTraces, 
                                                 function(x) {
                                                   t1 <- attributes(x)$time.begin.middlethird
                                                   t2 <- attributes(x)$time.end.middlethird
                                                   return(t2-t1)
                                                 }))
        Middlethird.begin.mean <- unlist(lapply(AnalyseTraces, 
                                                function(x) {
                                                  return(attributes(x)$time.begin.middlethird)
                                                }))
        Middlethird.end.mean <- unlist(lapply(AnalyseTraces, 
                                              function(x) {
                                                return(attributes(x)$time.end.middlethird)
                                              }))
        Incubation.length.mean <- unlist(lapply(AnalyseTraces, 
                                                function(x) {
                                                  return(x[nrow(x), "Time"])
                                                }))
        
        MiddleThird.TimeWeighted.temperature.mean <- unlist(lapply(AnalyseTraces, 
                                                                   function(x) {
                                                                     if (!is.na(attributes(x)$indice.begin.middlethird) & !is.na(attributes(x)$indice.end.middlethird)) {
                                                                       x2 <- x[(attributes(x)$indice.begin.middlethird):(attributes(x)$indice.end.middlethird-1), ]
                                                                       sum(x2[, "TempC"]*x2[, "DeltaT"])/sum(x2[, "DeltaT"])
                                                                     } else {NA}
                                                                   }))
        
        MiddleThird.MassWeighted.temperature.mean <- unlist(lapply(AnalyseTraces, 
                                                                   function(x) {
                                                                     if (!is.na(attributes(x)$indice.begin.middlethird) & !is.na(attributes(x)$indice.end.middlethird)) {
                                                                       x2 <- x[(attributes(x)$indice.begin.middlethird):(attributes(x)$indice.end.middlethird-1), "TempC"]
                                                                       dSCL <- c(diff(x[, "SCL"]), 0)[(attributes(x)$indice.begin.middlethird):(attributes(x)$indice.end.middlethird-1)]
                                                                       sum(x2*dSCL)/sum(dSCL)
                                                                     } else {NA}
                                                                   }))
        
        CTEA.TSP_CTEA.2ndT <- TSP.TimeWeighted.temperature.mean-MiddleThird.TimeWeighted.temperature.mean
          
        CTEW.TSP_CTEW.2ndT <- TSP.MassWeighted.temperature.mean-MiddleThird.MassWeighted.temperature.mean
        
        summarydf <- data.frame(
          TimeWeighted.temperature.mean=TimeWeighted.temperature.mean, 
          MassWeighted.temperature.mean=MassWeighted.temperature.mean, 
          TSP.TimeWeighted.temperature.mean=TSP.TimeWeighted.temperature.mean,
          TSP.MassWeighted.temperature.mean=TSP.MassWeighted.temperature.mean,
          TSP.STRNWeighted.temperature.mean=TSP.STRNWeighted.temperature.mean,
          TSP.MassWeighted.STRNWeighted.temperature.mean=TSP.MassWeighted.STRNWeighted.temperature.mean,
          TSP.length.mean=TSP.length.mean,
          TSP.begin.mean=TSP.begin.mean,
          TSP.end.mean=TSP.end.mean,
          Incubation.length.mean=Incubation.length.mean,
          Middlethird.length.mean=Middlethird.length.mean,
          Middlethird.begin.mean=Middlethird.begin.mean,
          Middlethird.end.mean=Middlethird.end.mean,
          MiddleThird.TimeWeighted.temperature.mean=MiddleThird.TimeWeighted.temperature.mean,
          MiddleThird.MassWeighted.temperature.mean=MiddleThird.MassWeighted.temperature.mean,
          CTEA.TSP_CTEA.2ndT=CTEA.TSP_CTEA.2ndT,
          CTEW.TSP_CTEW.2ndT=CTEW.TSP_CTEW.2ndT
        )
        returntotal.summary <- c(returntotal.summary, list(summarydf))
        
      }
    }
    
    # fin de la boucle des replicats
  }
  
  if (any(out=="likelihood")) return(returntotal.likelihood)
  
  ret.summary <- NULL
  ret.metric <- NULL
  
  if (any(out=="metric")) {
    
    # Il faut d'abord que je retire les temps crees pour le debut et la fin de la TSP
    # En fait le plus simple serait que je ne les mette pas si 
    # je suis en metric, seulement en summary
    
    # je sors la longeur max de la serie
    lmax <- sapply(returntotal.metric, function(x) sapply(x, function(y) dim(y)[1]))
    if (class(lmax)=="matrix") lmax <- lmax[,1]
    lmax <- aggregate(lmax, by=list(names(lmax)), max)
    rownames(lmax) <- lmax[,1]
    
    # l1 <- length(meanTotal[[j]])
    # l2 <- length(meanTotal_i[[j]])
    
    # D'abord je sors les valeurs pour le premier de la serie des randoms
    
    meanTotal <- lapply(returntotal.metric[[1]], function(x) x[,"SCL"])
    
    meanTotal <- lapply(name, function(x) c(meanTotal[[x]], rep(0, lmax[x, 2]-length(meanTotal[[x]]))))
    
    nbdif0 <- lapply(meanTotal, function(x) ifelse(x != 0, 1, 0))
    
    meanTotal2 <- lapply(returntotal.metric[[1]], function(x) x[,"SCL"]^2)
    meanTotal2 <- lapply(name, function(x) c(meanTotal2[[x]], rep(0, lmax[x, 2]-length(meanTotal2[[x]]))))
    meanRTotal <- lapply(returntotal.metric[[1]], function(x) x[,"R"])
    meanRTotal <- lapply(name, function(x) c(meanRTotal[[x]], rep(0, lmax[x, 2]-length(meanRTotal[[x]]))))
    meanRTotal2 <- lapply(returntotal.metric[[1]], function(x) x[,"R"]^2)
    meanRTotal2 <- lapply(name, function(x) c(meanRTotal2[[x]], rep(0, lmax[x, 2]-length(meanRTotal2[[x]]))))
    
    att <- lapply(returntotal.metric[[1]], function(x) c(
      attributes(x)[["time.begin.tsp"]], 
      attributes(x)[["time.end.tsp"]], 
      attributes(x)[["time.begin.middlethird"]],
      attributes(x)[["time.end.middlethird"]],
      attributes(x)[["metric.begin.tsp"]],
      attributes(x)[["metric.end.tsp"]], 
      attributes(x)[["test.mean"]], 
      attributes(x)[["test.sd"]], 
      attributes(x)[["metric.end.incubation"]]
    ))
    att2 <- lapply(returntotal.metric[[1]], function(x) c(
      attributes(x)[["time.begin.tsp"]]^2, 
      attributes(x)[["time.end.tsp"]]^2, 
      attributes(x)[["time.begin.middlethird"]]^2,
      attributes(x)[["time.end.middlethird"]]^2,
      attributes(x)[["metric.begin.tsp"]]^2,
      attributes(x)[["metric.end.tsp"]]^2, 
      attributes(x)[["test.mean"]]^2, 
      attributes(x)[["test.sd"]]^2, 
      attributes(x)[["metric.end.incubation"]]^2
    ))
    att_sat <- lapply(returntotal.metric[[1]], function(x) c(
      attributes(x)[["stopattest"]]
    ))
    
    if (length(returntotal.metric) != 1) {
      for (i in 2:length(returntotal.metric)) {
        meanTotal_i <- lapply(returntotal.metric[[i]], function(x) x[,"SCL"])
        meanTotal_i <- lapply(name, function(x) c(meanTotal_i[[x]], rep(0, lmax[x, 2]-length(meanTotal_i[[x]]))))
        
        meanTotal2_i <- lapply(returntotal.metric[[i]], function(x) x[,"SCL"]^2)
        meanTotal2_i <- lapply(name, function(x) c(meanTotal2_i[[x]], rep(0, lmax[x, 2]-length(meanTotal2_i[[x]]))))
        
        meanRTotal_i <- lapply(returntotal.metric[[i]], function(x) x[,"R"])
        meanRTotal_i <- lapply(name, function(x) c(meanRTotal_i[[x]], rep(0, lmax[x, 2]-length(meanRTotal_i[[x]]))))
        
        meanRTotal2_i <- lapply(returntotal.metric[[i]], function(x) x[,"R"]^2)
        meanRTotal2_i <- lapply(name, function(x) c(meanRTotal2_i[[x]], rep(0, lmax[x, 2]-length(meanRTotal2_i[[x]]))))
        
        att_i <- lapply(returntotal.metric[[i]], function(x) c(
          attributes(x)[["time.begin.tsp"]], 
          attributes(x)[["time.end.tsp"]], 
          attributes(x)[["time.begin.middlethird"]],
          attributes(x)[["time.end.middlethird"]],
          attributes(x)[["metric.begin.tsp"]],
          attributes(x)[["metric.end.tsp"]], 
          attributes(x)[["test.mean"]], 
          attributes(x)[["test.sd"]], 
          attributes(x)[["metric.end.incubation"]]
        ))
        att2_i <- lapply(returntotal.metric[[i]], function(x) c(
          attributes(x)[["time.begin.tsp"]]^2, 
          attributes(x)[["time.end.tsp"]]^2, 
          attributes(x)[["time.begin.middlethird"]]^2,
          attributes(x)[["time.end.middlethird"]]^2,
          attributes(x)[["metric.begin.tsp"]]^2,
          attributes(x)[["metric.end.tsp"]]^2, 
          attributes(x)[["test.mean"]]^2, 
          attributes(x)[["test.sd"]]^2, 
          attributes(x)[["metric.end.incubation"]]^2
        ))
        att_sat_i <- lapply(returntotal.metric[[i]], function(x) c(
          attributes(x)[["stopattest"]]
        ))   
        
        for(j in 1:length(meanTotal_i)) {
          meanTotal[[j]] <- meanTotal[[j]]+meanTotal_i[[j]]
          meanTotal2[[j]] <- meanTotal2[[j]]+meanTotal2_i[[j]]
          meanRTotal[[j]] <- meanRTotal[[j]]+meanRTotal_i[[j]]
          meanRTotal2[[j]] <- meanRTotal2[[j]]+meanRTotal2_i[[j]]
          
          nbdif1 <- lapply(meanTotal_i, function(x) ifelse(x != 0, 1, 0))
          
          nbdif0 <- lapply(name, function(x) nbdif0[[x]]+nbdif1[[x]])
          
          att[[j]] <- att[[j]]+att_i[[j]]
          att2[[j]] <- att2[[j]]+att2_i[[j]]
          att_sat[[j]] <- att_sat[[j]] | att_sat_i[[j]]
          
        }
      }
    }
    
    
    ret <- returntotal.metric[[1]]
    
    # sum(a^2)-length(a)*mean(a)^2)/(length(a)-1)
    # dans meantotal j'ai une liste avec la moyenne des tailles pour chaque temps
    # dans meantotal2, j'ai la moyenne des carres des tailles
    
    for(j in name) {
      
      # j prend l'indice des differents nids suivis
      # nbdif0 est le nombre de donnees utilisables; si >1 calcule le SE des tailles dans se_i
      se_i <- ifelse(nbdif0[[j]]>1, 
                     (meanTotal2[[j]]-nbdif0[[j]]*(meanTotal[[j]]/nbdif0[[j]])^2)/(nbdif0[[j]]-1), 
                     NA)
      se_i <- ifelse(is.na(se_i), NA, sqrt(ifelse(se_i<=0, 0,se_i)))
      # calcul le SE de R pour chaque temps dans seR_i
      seR_i <- ifelse(nbdif0[[j]]>1, 
                      (meanRTotal2[[j]]-nbdif0[[j]]*(meanRTotal[[j]]/nbdif0[[j]])^2)/(nbdif0[[j]]-1),
                      NA)
      seR_i <- ifelse(is.na(seR_i), NA, sqrt(ifelse(seR_i<=0, 0,seR_i)))
      
      # dans ret, j'ai une liste avec tous les tableaux complets
      # "Time"    "TempC"   "TempK"   "R"       "SCL"     "IndiceK" "DeltaT"
      intret <- ret[[j]]
      # lmax est un data.frame avec le nom de la serie et l'indice max
      
      if (lmax[j, 2] != dim(intret)[1]) {
        missinglines <- rep(NA, lmax[j, 2]-dim(intret)[1])
        intret <- rbind(intret, data.frame(Time=missinglines, TempC=missinglines, TempK=missinglines,
                                           R=missinglines, SCL=missinglines, IndiceK=missinglines, 
                                           DeltaT=missinglines))
      }
      
      
      ret[[j]] <- cbind(intret, mean.SCL=meanTotal[[j]]/nbdif0[[j]], 
                        mean.R=meanRTotal[[j]]/nbdif0[[j]], 
                        se.SCL=se_i, se.R=seR_i)
      
      # je fais les attributs
      mean_att_i <- att[[j]]/replicate.CI
      se_att_i <- (att2[[j]]-replicate.CI*mean_att_i^2)/(replicate.CI-1)
      se_att_i <- sqrt(ifelse(se_att_i<=0, 0, se_att_i))
      attributes(ret[[j]])$time.begin.tsp <- mean_att_i[1]
      attributes(ret[[j]])$time.end.tsp <- mean_att_i[2]
      attributes(ret[[j]])$time.begin.middlethird <- mean_att_i[3]
      attributes(ret[[j]])$time.end.middlethird <- mean_att_i[4]
      attributes(ret[[j]])$metric.begin.tsp <- mean_att_i[5]
      attributes(ret[[j]])$metric.end.tsp <- mean_att_i[6]
      attributes(ret[[j]])$test.mean <- mean_att_i[7]
      attributes(ret[[j]])$test.sd <- mean_att_i[8]
      attributes(ret[[j]])$metric.end.incubation <- mean_att_i[9]
      attributes(ret[[j]])$time.begin.tsp.se <- se_att_i[1]
      attributes(ret[[j]])$time.end.tsp.se <- se_att_i[2]
      attributes(ret[[j]])$time.begin.middlethird.se <- se_att_i[3]
      attributes(ret[[j]])$time.end.middlethird.se <- se_att_i[4]
      attributes(ret[[j]])$stopattest <- att_sat[[j]]
      
      
    }
    ret.metric <- ret
  }
  
  
  if (any(out=="summary")) {
    
    # save(returntotal.summary, file="returntotal.summary.Rdata")
    
    if (replicate.CI != 1) {
      
      a <- lapply(returntotal.summary, function(x) as.matrix(x))
      b <- array(unlist(a), dim=c(dim(a[[1]]), length(a)), dimnames = list(rownames(a[[1]]), colnames(a[[1]]), NULL))
      
      meanTotal <- apply(b, MARGIN=c(1, 2), FUN=mean, na.rm = TRUE)
      df_se <- apply(b, MARGIN=c(1, 2), FUN=sd, na.rm = TRUE)
      
      colnames(df_se) <- paste0(gsub("(.+)\\.mean", "\\1", colnames(df_se)), ".se")
      ret.summary <- cbind(meanTotal, df_se)
      
    } else {
      
      df_se <- as.matrix(returntotal.summary[[1]])
      df_se[, ] <- NA
      df_se <- as.data.frame(df_se)
      colnames(df_se) <- paste0(gsub("(.+)\\.mean", "\\1", colnames(df_se)), ".se")
      
      ret.summary <- cbind(returntotal.summary[[1]], df_se)
    }
  }
  return(list(metric=ret.metric, summary=ret.summary))
}
